from pathlib import Path
import re

# --- Directories ---
chapter_base_dir = Path("textbook-datascience-1/textbook/")
output_term = chapter_base_dir / "glossary.md"
output_code = chapter_base_dir / "code-glossary.md"

# --- Helper function to parse glossary entries ---
def parse_entries(file_list):
    entries = []
    for file in sorted(file_list):
        lines = file.read_text().splitlines()
        current = []
        for line in lines:
            if line.startswith("## "):
                if current:
                    entries.append(current)
                current = [line]
            else:
                current.append(line)
        if current:
            entries.append(current)
    return sorted(entries, key=lambda e: e[0].lower())

# --- Collect glossary files ---
term_files = list(chapter_base_dir.rglob("*-glossary.md"))
code_files = list(chapter_base_dir.rglob("*-code-glossary.md"))

# --- Parse and write master glossary ---
term_entries = parse_entries(term_files)
code_entries = parse_entries(code_files)

output_term.parent.mkdir(parents=True, exist_ok=True)

with output_term.open("w") as f:
    f.write("# Glossary of Terms\n\n")
    f.write("<!-- AUTO-GENERATED: Do not edit this file directly -->\n\n")
    for entry in term_entries:
        f.write("\n".join(entry).strip() + "\n\n")

with output_code.open("w") as f:
    f.write("# Glossary of Code\n\n")
    f.write("<!-- AUTO-GENERATED: Do not edit this file directly -->\n\n")
    for entry in code_entries:
        f.write("\n".join(entry).strip() + "\n\n")

# --- Function to generate summary items from glossary entries ---
def summarize_entries(entries):
    summary = []
    for entry in entries:
        if not entry: continue
        title_line = entry[0]
        term = title_line.replace("##", "").strip("` ").strip()
        desc_line = next((line for line in entry[1:] if line.strip()), "")
        first_sentence = re.split(r"\.|\n", desc_line.strip())[0]
        summary.append(f"- **{term}**: {first_sentence}")
    return summary

# --- Insert "New in This Chapter" blocks at end of final subsection ---
def insert_at_end_of_file(md_file, term_summary, code_summary):
    marker_start = "<!-- NEW_TERMS_START -->"
    marker_end = "<!-- NEW_TERMS_END -->"
    block = ["\n", marker_start, ":::: {.tip title=\"New in This Chapter\"}"]
    block += term_summary + code_summary
    block += ["::::", marker_end, "\n"]
    block_str = "\n".join(block)

    if md_file.exists():
        content = md_file.read_text()
        if marker_start in content and marker_end in content:
            content = re.sub(
                f"{marker_start}.*?{marker_end}",
                f"{marker_start}\n:::: {{.tip title=\"New in This Chapter\"}}\n" +
                "\n".join(term_summary + code_summary) + "\n::::\n" +
                f"{marker_end}",
                content,
                flags=re.DOTALL
            )
        else:
            content = content.rstrip() + block_str
        md_file.write_text(content)

# --- Process each chapter folder ---
for chapter_dir in sorted(chapter_base_dir.glob("??")):
    chapter_num = chapter_dir.name
    term_file = next(chapter_dir.rglob("*-glossary.md"), None)
    code_file = next(chapter_dir.rglob("*-code-glossary.md"), None)
    if not term_file and not code_file:
        continue

    term_entries = parse_entries([term_file]) if term_file else []
    code_entries = parse_entries([code_file]) if code_file else []
    term_summary = summarize_entries(term_entries)
    code_summary = summarize_entries(code_entries)

    # Find last subsection file in numerically sorted order
    subsection_dirs = sorted(chapter_dir.glob("[0-9]*"))
    if subsection_dirs:
        last_dir = sorted(subsection_dirs, key=lambda x: int(x.name))[-1]
        md_files = sorted(last_dir.glob("*.md"))
        if md_files:
            last_md_file = md_files[-1]
            insert_at_end_of_file(last_md_file, term_summary, code_summary)
